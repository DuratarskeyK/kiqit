{"name":"Kiqit","tagline":"Your SideKiq helper","body":"[![Build Status](https://secure.travis-ci.org/KensoDev/kiqit.png)](https://secure.travis-ci.org/KensoDev/kiqit)\r\n\r\n## Overview\r\nKiqit is a gem meant to work with the [Sidekiq](http://github.com/mperham/sidekiq) queue system. It was adapted from the Perform Later gem.\r\n\r\nUsually, when working with Sidekiq, you need separate \"Worker\" classes and you also need to do `Sidekiq.enqueue` whenever you want to add a task to the queue.\r\n\r\nThat can be a real hassle if you are adding Sidekiq to an existing project, it can also add quite a bit of code to your system.\r\n\r\n`kiqit` fills this need, it offers a suite to handle all of your queuing needs, both for Objects and for ActiveRecord models.\r\n\r\n## Why?\r\n*Why* should you queue something for later?\r\n\r\nYou should queue something whenever the method handles some heavy lifting, some timely actions like API, 3rd party HTTP requests and more.\r\n\r\nThe basic logic is that whatever you don't need to do NOW, you should do later, this will make your site faster and the users will feel it.\r\n\r\n## Real life use case\r\nAt [Gogobot](http://gogobot.com) whenever you post a review, there's major score calculation going on. This can sometimes take up to a minute, depending on the user graph.\r\n\r\nThe user should not wait for this on submit, it can be queued into later execution.\r\n\r\n## Installation\r\ngem install kiqit\r\n\r\nIf you are using bundler, simply add\r\n`gem \"kiqit\"` to your Gemfile\r\n\r\n\r\n## Configuration\r\nIn an initializer, all you need to say is whether you want kiqit to be enabled or not, typically, it will be something like this\r\n\r\n```ruby\r\nunless Rails.env.test?\r\n  Kiqit.config.enabled = true # this will default to false if unset\r\nend\r\n```\r\n\r\n## Usage\r\n\r\n### ActiveRecord\r\n\r\n`kiqit` comes with a special method you can use on ActiveRecord models.\r\n\r\n\r\n```ruby\r\n\r\n\tclass User < ActiveRecord::Base\r\n\t  def long_running_method\r\n\t    # Your code here\r\n\t  end\r\n\t  later :long_running_method\r\n\t\r\n\t  def long_running_method_2\r\n\t    # Your code here\r\n\t  end\r\n\t  later :long_running_method_2, queue: :some_queue_name\r\n\t\r\n\t  def lonely_long_running_method\r\n\t    # Your code here\r\n\t  end\r\n\t  later :lonely_long_running_method, :loner => true, queue: :some_queue_name\r\n\r\n    def delayed_long_running_method\r\n      # Your code here\r\n    end\r\n    later :delayed_long_running_method, :delay => 30, queue: :some_queue_name\r\n\tend\r\n\t\r\n```\r\n\r\n```ruby\r\n\tu = User.find(some_user_id)\r\n\tu.long_running_method # Method will be queued into the :generic queue\r\n\tu.long_running_method_2 # Method will be queued into :some_queue_name queue\r\n\tu.lonely_long_running_method # Method will be queued into the :some_queue_name queue, only a single instance of this method can exist in the queue.\r\n  u.delayed_long_running_method # Method will be queued into :some_queue_name queue only after 30 seconds have passed.\r\n```\r\n\r\nYou can of course choose to run the method off the queue, just prepend `now_` to the method name and it will be executed in sync.\r\n\r\n```ruby\r\n\tu = User.find(some_user_id)\r\n\tu.now_long_running_method\r\n```\r\n\r\n### Objects/Classes\r\n\r\nIf you want class methods to be queued, you will have to use the `kiqit` special method.\r\n\r\n```ruby\r\n\tclass SomeClass\r\n\t\tdef self.some_heavy_lifting_method\r\n\t  \t  # Your code here\r\n\t  \tend\r\n\t  \t\r\n\t\tdef self.some_more_heavy_lifting(user_id)\r\n\t  \t  # Your code here\r\n\t  \tend  \t\r\n\tend\r\n\t\r\n\tSomeClass.kiqit(:queue_name, :some_heavy_lifting_method)\r\n\tSomeClass.kiqit(:queue_name, :some_more_heavy_lifting, user_id)\r\n\t\r\n\r\n```\r\n\r\nIf you want the method to be a loner (only a single instance in the queue), you will need to use the `kiqit!` method.\r\n\r\n```ruby\r\n\tSomeClass.kiqit!(:queue_name, :some_more_heavy_lifting, user_id)\r\n```\r\n\r\n## The params parser\r\n`kiqit` has a special class called `ArgsParser`, this class is in charge of *translating* the args you are passing into params that can actually be serialized to JSON cleanly.\r\n\r\nExamples:\r\n\r\n```ruby\r\n\tuser = User.find(1)\r\n\tKiqit::ArgsParser.params_to_sidekiq(user) => 'AR:#User:1'\r\n\t\r\n\thotel = Hotel.find(1)\r\n\tKiqit::ArgsParser.params_to_sidekiq(hotel) => 'AR:#Hotel:1'\r\n\t\r\n\thash = { name: \"something\", other: \"something else\" }\r\n\tKiqit::ArgsParser.params_to_sidekiq(hash) \r\n\t=> ---\r\n\t\t:name: something\r\n\t\t:other: something else\r\n\t# Hashes are translated into YAML\r\n```\r\n\r\nBasically, the `ArgsParser` class allows you to keep passing any args you want to your methods without worrying about whether they serialize cleanly or not.\r\n\r\n`ArgsParser` also patched `sidekiq-mailer` so you can pass in AR objects to mailers as well.\r\n\r\n## The custom finder\r\nI found the need to add a custom finder to the args parser.\r\n\r\n### Why?\r\nAt Gogobot for example, we use slave databases, those sometimes have lag, so when the finder is executed it returns nil, even though the record is actually on the master.\r\n\r\nSo, I added support for custom finders.\r\n\r\n#### Example:\r\n\r\n```ruby\r\n\tclass CustomFinder\r\n\t\tdef self.find(klass, id)\r\n\t\t\tOctopus.using(:master) {\r\n\t\t\t\tklass.where(id: id).first\r\n\t\t\t} unless klass.where(id: id).first\r\n\t\tend\r\n\tend\r\n```\r\n\r\nThen in an initializer\r\n\r\n```ruby\r\n\tKiqit::Plugins.add_finder(CustomFinder)\r\n```\r\n\r\nYou can also remove the finder in runtime\r\n\r\n```ruby\r\n\tKiqit::Plugins.clear_finder!\r\n```\r\n\r\nSo, at Gogobot for example, we will fall back to master if the record was not found on the slave DB.\r\n\r\n \r\n## Contribute / Bug reports\r\n\r\nIf you have an issue with this gem, please open an issue in the main repo, it will help tons if you could supply a failing spec with that, so I can better track where the bug is coming from, if not, no worries, just report I will do my best to address it as fast and efficient as I can.\r\n\r\nIf you want to contribute (awesome), open a feature branch, base it on master.\r\n\r\nBe as descriptive as you can in the pull request description, just to be clear what problem you are solving or what feature are you adding.\r\n\r\n## Authors\r\n\r\nAvi Tzurel ([@kensodev](http://twitter.com/kensodev)) http://www.kensodev.com\r\nTom Caspy\r\n\r\n## Contributors\r\n\r\n* Felipe Lima ([@felipecsl](http://twitter.com/felipecsl)) \r\nhttp://blog.felipel.com/\r\n\r\nFelipe did awesome work on making sure `kiqit` can work with any args and any number of args passed into the methods.\r\nFelipe now has commit rights to the repo.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}